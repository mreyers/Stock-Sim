This is the beginning of a hopefully interesting stock simulation. I came across the thought recently of how a randomly divised portfolio would perform over different time periods. When I say randomly divised, I am talking about every aspect of the portfolio with only minor modifications. How many stocks should be owned? What stocks should be purchased? How much of each stock should be in the portfolio? There may be more random elements explored later, though for now I will focus on these.

Some basic assumptions and set up I will be doing for this project. First, stocks will be purchased at open on the first trading day of the year and sold at close on the last trading day of the year. There will be no opportunity to sell during the year for this simulation though I may explore the maximum possible gain/loss for each portfolio and the actual outcome. 

To begin, I will load in the data from the kaggle dataset, downloadable at: https://www.kaggle.com/borismarjanovic/price-volume-data-for-all-us-stocks-etfs#Data.zip

Read in this data.

```{r message = FALSE}
pacman::p_load(tidyverse)

test <- read_csv("Stocks/a.us.txt")

stocks_csv <- paste0("Stocks/", list.files("Stocks/", pattern = "*.txt"))
stocks <- lapply(stocks_csv, read_csv)

ETF_csv <- paste0("ETFs/", list.files("ETFs/", pattern = "*.txt"))
ETF <- lapply(ETF_csv, read_csv)
```
There is some cleaning that has to take place prior to this step if using this approach. In the Stocks folder, a handful of files have no data entry. These files can be deleted manually or dealt with through some cumbersome if statement filtering. I went with the former. The collection of ETFs does not have any empty files, though it has two files (tvix and uvxy) that are miscoded with an extra column. Again, workarounds could be had. I will proceed with just deleting these two files, however, and revisit this problem later. 

Now to build the basics of the randomization engine. I listed previously the things that I want to randomize in this project. Below is my approach. Note that due to commissions on most trading accounts, I am putting a higher weight on smaller account sizes as a way of exploring a feasible strategy for the average trader. I will later expand to equal probability across all stocks as platforms such as Robinhood and others are making accounts of that diversity feasible.
```{r}
n_stocks <- length(stocks)
weights <-  exp(-1 * seq(1, n_stocks)) / sum(exp(-1 * seq(1, n_stocks))) # I can explore other transformations as well
n_samp <- sample(seq(1, n_stocks), size = 1, prob = weights) # Chooses portfolio size

# Now to choose the stocks
selected_stocks <- sample(seq(1, n_stocks), size = n_samp)
stock_sim <- stocks[selected_stocks]

```
I encountered an obvious problem with this approach in an initial run through. This data set is a collection of all the stocks that have been traded between 1999 and 2017 on a US exchange. This means that some companies have not been listed for the entire duration. The problem here is that not all portfolios would have a chance to invest in the entirety of the stocks. Therefore there must be some effort to condense the number of stocks to the number available in a given year. For instance, consider the year 2000. Based on the trading scheme devised here, I would need to be able to purchase the stock in early January and sell in late december. For ease I will allow a 7 day buffer on either side, meaning that if a company has a first trade date before January 8th and a last trade date after December 24th then the stock will be considered elligible for that year. 

```{r}
# Years of interest: 2000-2016
start.Date <- as.POSIXct("2000-01-08")
end.Date <- as.POSIXct("2000-12-24")

testing <- stocks
filterFunction <- function(aList, first, last){
  if(min(aList$Date) < first & max(aList$Date) > last ){
    return(aList)
  }
  else{
    return("NotTraded")
  }
}
myTest <- lapply(testing, filterFunction, start.Date, end.Date)
cleanedList <- Filter(function(x) {nrow(x) >= 2}, myTest) # Keeps only the stocks that were available year round for this given start/end

```

